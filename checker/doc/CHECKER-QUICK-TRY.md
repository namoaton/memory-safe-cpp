

Quick try
=========

To run a very simple first sample, you only need to have `nodecpp-checker.exe` on your `PATH`.
If you downloaded a binary file, you can just copy it into the folder `checker/test/nodecpp-checker`. If you built it from source code, or prefer to put your binaries somewhere else, just open a console and set your env:

	set PATH=path\to\tool\exe;%PATH%

Where `path/to/tool/exe` may be full path of `checker/build/vs2017/Release/bin` if you compiled the tool with VS2017 command line tools, similar thing under Linux but for the path  `checker/build/release/bin`.

Then go to folder with test cases `checker/test/nodecpp-checker` and run:

	> cd checker\test\nodecpp-checker
	> nodecpp-checker s1-1.cpp
	> nodecpp-checker s1-4.cpp
	> nodecpp-checker s5-3.cpp
	> nodecpp-checker s8.cpp

You can run the tool over any of the `.cpp` files on that folder. However there is one important limitation in this _simple_ mode, that tests can't access the __std__ library on your system, or the real `safe_ptr.h` library, they use a small _mock_ of them found in `Inputs` folders. This is done such way to improve test stability.

Safe library and compilation database
-------------------------------------
Also important to notice is that `nodecpp-checker` will automatically pick `safe_library.json` and `compile_flags.txt` from the source folder.
Please see [CHECHER-RUN.md](CHECHER-RUN.md) to better understand how those files fit inside the process and when you may need to modify them for your specific needs.

Next
----
See [CHECHER-RUN.md](CHECHER-RUN.md) to set up the environment to run the tool over your own files or projects.

Or take a look at [CHECKER-TEST.md](CHECKER-TEST.md) to run or add automated test cases.












We will assume that `nodecpp-checker` and `nodecpp-safe-library` tools are already built and in the PATH.
If not, take a look at [CHECKER-BUILD.md](CHECKER-BUILD.md).

Safe library database
---------------------

Rule 8 of STATIC-CHECKS.md states:

	[Rule S8] Prohibit functions except for those safe ones

In order to enforce such rule, exists the safe library database.
The safe library database is json serialized file used by `nodecpp-checker` and generated by `nodecpp-safe-library`, the file name is usualy `safe_library.json`

To generate a safe library database, we use `nodecpp-safe-library` tool. This tool will read a normal C++ header file (please use .hpp extension). Example:

	namespace fmt {
	namespace v5 {
		void print();
	}	
	}
	void make_owning();

	class owning_ptr;
	class naked_ptr;

This will create a safe library database that has the given functions and classes as safe.

When `nodecpp-checker` is run, we can pass a database path in the command line, or the tool will try to automatically find it in the same path of the source file, or any parent folder.
If no database is found, the tool will run anyway, but all functions and classes defined in _system_ libraries will be considered as __unsafe__


Checking code
-------------
To run the tool on a simple file (without any `#include`), and assuming that `safe_library.json` is in the same folder, just run:

	nodecpp-checker file.cpp --

If safe library database is at a different place, add command line argument:

	nodecpp-checker file.cpp -safe-library-db=/path/to/safe_library.json --


If we need to include some library (like `fmt` or `safe_ptr`) then we add `isystem` after the double hypen with the include path

	nodecpp-checker file.cpp -- -isystem /absolute/path/to/library/include/

After the double hypen, we can also add any compiler flag our code may need, like defines

	nodecpp-checker file.cpp -- -DNDEBUG


It is important that the tool gets exactly the same code than the compiler will see after preprocessing.
Bacuse of that, is important to have the same set of includes and defines.

Like all tools based on clang tooling, `nodecpp-checker` has three ways of doing that.

1. Like shown before, add the same command line options after the double hypen.
2. Put a file named `compiler_flags.txt` on the same folder that the source, with the options.
3. Use a compilation database generated by `cmake` or similar tool (`compile_commands.json`)

For more information, please see https://clang.llvm.org/docs/JSONCompilationDatabase.html

